# Chapter 12. Serialization

* “THIS chapter concerns *object serialization*, which is Java’s framework for encoding objects as byte streams (*serializing*) and reconstructing objects from their encodings (*deserializing*). Once an object has been serialized, its encoding can be sent from one VM to another or stored on disk for later deserialization. This chapter focuses on the dangers of serialization and how to minimize them.”


## Item 85: Prefer alternatives to Java serialization

* “A fundamental problem with serialization is that its *attack surface* is too big to protect, and constantly growing: Object graphs are deserialized by invoking the `readObject` method on an `ObjectInputStream`. This method is essentially a magic constructor that can be made to instantiate objects of almost any type on the class path, so long as the type implements the `Serializable` interface. In the process of deserializing a byte stream, this method can execute code from any of these types, so the code for all of these types is part of the attack surface.”
* “Without using any gadgets, you can easily mount a denial-of-service attack by causing the deserialization of a short stream that requires a long time to deserialize. Such streams are known as *deserialization bombs* [Svoboda16].”
* **“The best way to avoid serialization exploits is never to deserialize anything.”**
* **“There is no reason to use Java serialization in any new system you write.”**
  * “If you can’t avoid Java serialization entirely, perhaps because you’re working in the context of a legacy system that requires it, your next best alternative is to **never deserialize untrusted data**.”

* “The leading cross-platform structured data representations are JSON [JSON] and Protocol Buffers, also known as protobuf [Protobuf].”
  * “The most significant differences between JSON and protobuf are that JSON is text-based and human-readable, whereas protobuf is binary and substantially more efficient; and that JSON is exclusively a data representation, whereas protobuf offers *schemas* (types) to document and enforce appropriate usage. ”
* “If you can’t avoid serialization and you aren’t absolutely certain of the safety of the data you’re deserializing, use the object deserialization filtering added in Java 9 and backported to earlier releases (`java.io.ObjectInputFilter`). ”
  * “This facility lets you specify a filter that is applied to data streams before they’re deserialized. It operates at the class granularity, letting you accept or reject certain classes.”
  * “Accepting classes by default and rejecting a list of potentially dangerous ones is known as *blacklisting*; rejecting classes by default and accepting a list of those that are presumed safe is known as *whitelisting*.”
  * “**Prefer whitelisting to blacklisting**, as blacklisting only protects you against known threats.”
* **“In summary, serialization is dangerous and should be avoided. If you are designing a system from scratch, use a cross-platform structured-data representation such as JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use object deserialization filtering, but be aware that it is not guaranteed to thwart all attacks. Avoid writing serializable classes. If you must do so, exercise great caution.”**

## Item 86: Implement `Serializable` with great caution

* **“A major cost of implementing `Serializable` is that it decreases the flexibility to change a class’s implementation once it has been released.”**
  * “When a class implements `Serializable`, its byte-stream encoding (or *serialized form*) becomes part of its exported API.”
  * “If you do not make the effort to design a *custom serialized form* but merely accept the default, the serialized form will forever be tied to the class’s original internal representation.”
  * “It is possible to change the internal representation while maintaining the original serialized form (using `ObjectOutputStream.putFields` and `ObjectInputStream.readFields`), but it can be difficult and leaves visible warts in the source code.”
* “A simple example of the constraints on evolution imposed by serializability concerns *stream unique identifiers*, more commonly known as *serial version UIDs*. Every serializable class has a unique identification number associated with it.”
  * “If you do not specify this number by declaring a static final `long` field named `serialVersionUID`, the system automatically generates it at runtime by applying a cryptographic hash function (SHA-1) to the structure of the class.”
  * “This value is affected by the names of the class, the interfaces it implements, and most of its members, including synthetic members generated by the compiler. If you change any of these things, for example, by adding a convenience method, the generated serial version UID changes.”
  * “If you fail to declare a serial version UID, compatibility will be broken, resulting in an `InvalidClassException` at runtime.”
* **“A second cost of implementing `Serializable` is that it increases the likelihood of bugs and security holes (Item 85).”**
  * “Normally, objects are created with constructors; serialization is an *extralinguistic mechanism* for creating objects.”
    * “Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (Item 88).”
* **“A third cost of implementing `Serializable` is that it increases the testing burden associated with releasing a new version of a class.”**
  * “When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa. ”
  * “The need for testing is reduced if a custom serialized form is carefully designed when the class is first written (Items 87, 90).”
* **“Implementing `Serializable` is not a decision to be undertaken lightly.”**
  * “It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence.”
  * “Also, it greatly eases the use of a class as a component in another class that must implement `Serializable`.”
    * “Classes representing active entities, such as thread pools, should rarely implement `Serializable`.”
* **“Classes designed for inheritance (Item 19) should rarely implement `Serializable`, and interfaces should rarely extend it.”**
  * “Classes designed for inheritance that do implement `Serializable` include `Throwable` and `Component`. `Throwable` implements `Serializable` so RMI can send exceptions from server to client. `Component` implements `Serializable` so GUIs can be sent, saved, and restored, but even in the heyday of Swing and AWT, this facility was little-used in practice.”
  * “If you implement a class with instance fields that is both serializable and extendable, there are several risks to be aware of.”
    * “If there are any invariants on the instance field values, it is critical to prevent subclasses from overriding the `finalize` method, which the class can do by overriding `finalize` and declaring it final. Otherwise, the class will be susceptible to *finalizer attacks* (Item 8).”
    * “Finally, if the class has invariants that would be violated if its instance fields were initialized to their default values (zero for integral types, `false` for `boolean`, and `null` for object reference types), you must add this `readObjectNoData` method:”

```java
// readObjectNoData for stateful extendable serializable classes
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("Stream data required");
}
```

* “There is one caveat regarding the decision *not* to implement `Serializable`. If a class designed for inheritance is not serializable, it may require extra effort to write a serializable subclass. ”
  * “Normal deserialization of such a class requires the superclass to have an accessible parameterless constructor [Serialization, 1.10]. If you don’t provide such a constructor, subclasses are forced to use the serialization proxy pattern (Item 90).”
* **“Inner classes (Item 24) should not implement `Serializable`.”**
  * “They use compiler-generated *synthetic fields* to store references to *enclosing instances* and to store values of local variables from enclosing scopes. How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes.”
  * “A *static member class* can, however, implement `Serializable`.”
* **“To summarize, the ease of implementing `Serializable` is specious. Unless a class is to be used only in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data, implementing `Serializable` is a serious commitment that should be made with great care. Extra caution is warranted if a class permits inheritance.”**

## Item 87: Consider using a custom serialized form

* **“Do not accept the default serialized form without first considering whether it is appropriate.”**
* “The ideal serialized form of an object contains only the *logical* data represented by the object. It is independent of the physical representation.”
  * **“The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.”**

```java
// Good candidate for default serialized form
public class Name implements Serializable {
    /**
     * Last name. Must be non-null.
     * @serial
     */
    private final String lastName;

    /**
     * First name. Must be non-null.
     * @serial
     */
    private final String firstName;
    /**
     * Middle name, or null if there is none.
     * @serial
     */
    private final String middleName;

    ... // Remainder omitted
}
```

* **“Even if you decide that the default serialized form is appropriate, you often must provide a `readObject` method to ensure invariants and security.”**
* “Note that there are documentation comments on the `lastName`, `firstName`, and `middleName` fields, even though they are private. That is because these private fields define a public API, which is the serialized form of the class, and this public API must be documented. The presence of the `@serial` tag tells Javadoc to place this documentation on a special page that documents serialized forms.”


```java
// Awful candidate for default serialized form
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
        String data;
        Entry  next;
        Entry  previous;
    }

    ... // Remainder omitted
}
```

* **“Using the default serialized form when an object’s physical representation differs substantially from its logical data content has four disadvantages:”**
  * **“It permanently ties the exported API to the current internal representation.”**
  * **“It can consume excessive space.”**
  * **“It can consume excessive time.”**
  * **“It can cause stack overflows.”**
* “Here is a revised version of `StringList` with `writeObject` and `readObject` methods that implement this serialized form. As a reminder, the `transient` modifier indicates that an instance field is to be omitted from a class’s default serialized form:”


```java
// StringList with a reasonable custom serialized form
public final class StringList implements Serializable {
    private transient int size   = 0;
    private transient Entry head = null;

    // No longer Serializable!
    private static class Entry {
        String data;
        Entry  next;
        Entry  previous;
    }

    // Appends the specified string to the list
    public final void add(String s) { ... }

    /**
     * Serialize this {@code StringList} instance.
     *
     * @serialData The size of the list (the number of strings
     * it contains) is emitted ({@code int}), followed by all of
     * its elements (each a {@code String}), in the proper
     * sequence.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
        s.defaultWriteObject();
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Entry e = head; e != null; e = e.next)
            s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numElements = s.readInt();

        // Read in all elements and insert them in list
        for (int i = 0; i < numElements; i++)
            add((String) s.readObject());
    }

    ... // Remainder omitted
}
```

* “The first thing `writeObject` does is to invoke `defaultWriteObject`, and the first thing `readObject` does is to invoke `defaultReadObject`, even though all of `StringList`’s fields are transient.”
  * “Had the earlier version’s `readObject` method failed to invoke `defaultReadObject`, the deserialization would fail with a `StreamCorruptedException`.”
* **“Before deciding to make a field nontransient, convince yourself that its value is part of the logical state of the object.”**
  * “If you use a custom serialized form, most or all of the instance fields should be labeled `transient`, as in the `StringList` example above.”
* “If you are using the default serialized form and you have labeled one or more fields `transient`, remember that these fields will be initialized to their *default values* when an instance is deserialized”
  * “If these values are unacceptable for any transient fields, you must provide a `readObject` method that invokes the `defaultReadObject` method and then restores transient fields to acceptable values (Item 88).”
  * “Alternatively, these fields can be lazily initialized the first time they are used (Item 83).”
* “Whether or not you use the default serialized form, **you must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object**.”

```java
// writeObject for synchronized class with default serialized form
private synchronized void writeObject(ObjectOutputStream s)
        throws IOException {
    s.defaultWriteObject();
}
```

* “If you put synchronization in the `writeObject` method, you must ensure that it adheres to the same lock-ordering constraints as other activities, or you risk a resource-ordering deadlock [Goetz06, 10.1.5].”
* **“Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.”**
  * “This eliminates the serial version UID as a potential source of incompatibility (Item 86).”

  * “If no serial version UID is provided, an expensive computation is performed to generate one at runtime.”

```java
private static final long serialVersionUID = randomLongValue;
```

* “If you write a new class, it doesn’t matter what value you choose for `randomLongValue`. You can generate the value by running the `serialver` utility on the class, but it’s also fine to pick a number out of thin air.”
* “If you ever want to make a new version of a class that is incompatible with existing versions, merely change the value in the serial version UID declaration.”
  * **“Do not change the serial version UID unless you want to break compatibility with all existing serialized instances of a class.”**
* **“To summarize, if you have decided that a class should be serializable (Item 86), think hard about what the serialized form should be. Use the default serialized form *only* if it is a reasonable description of the logical state of the object; otherwise design a custom serialized form that aptly describes the object. You should allocate as much time to designing the serialized form of a class as you allocate to designing an exported method (Item 51). Just as you can’t eliminate exported methods from future versions, you can’t eliminate fields from the serialized form; they must be preserved forever to ensure serialization compatibility. Choosing the wrong serialized form can have a permanent, negative impact on the complexity and performance of a class.”**

## Item 88: Write `readObject` methods defensively

* **“When an object is deserialized, it is critical to defensively copy any field containing an object reference that a client must not possess.”**
  * “Therefore, every serializable immutable class containing private mutable components must defensively copy these components in its `readObject` method.”

```java
// readObject method with defensive copying and validity checking
private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
    s.defaultReadObject();

    // Defensively copy our mutable components
    start = new Date(start.getTime());
    end   = new Date(end.getTime());

    // Check that our invariants are satisfied
    if (start.compareTo(end) > 0)
        throw new InvalidObjectException(start +" after "+ end);
}
```

* “Note that the defensive copy is performed prior to the validity check and that we did not use `Date`’s `clone` method to perform the defensive copy. Both of these details are required to protect `Period` against attack (Item 50). Note also that defensive copying is not possible for final fields.”
* “To use the `readObject` method, we must make the `start` and `end` fields nonfinal. This is unfortunate, but it is the lesser of two evils. With the new `readObject` method in place and the `final` modifier removed from the `start` and `end` fields, the `MutablePeriod` class is rendered ineffective.”
* “Alternatively, you can use the *serialization proxy pattern* (Item 90). This pattern is highly recommended because it takes much of the effort out of safe deserialization.”
* **“Like a constructor, a `readObject` method must not invoke an overridable method, either directly or indirectly (Item 19).”**
  * “If this rule is violated and the method in question is overridden, the overriding method will run before the subclass’s state has been deserialized.”
* **“To summarize, anytime you write a `readObject` method, adopt the mind-set that you are writing a public constructor that must produce a valid instance regardless of what byte stream it is given. Do not assume that the byte stream represents an actual serialized instance.”**
* **“Here, in summary form, are the guidelines for writing a `readObject` method:”**
  * “For classes with object reference fields that must remain private, defensively copy each object in such a field. Mutable components of immutable classes fall into this category.”
  * “Check any invariants and throw an `InvalidObjectException` if a check fails. The checks should follow any defensive copying.”
  * “If an entire object graph must be validated after it is deserialized, use the `ObjectInputValidation` interface (not discussed in this book).”
  * “Do not invoke any overridable methods in the class, directly or indirectly.”


## Item 89: For instance control, prefer enum types to `readResolve`

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {  ... }

    public void leaveTheBuilding() { ... }
}
```

* “As noted in Item 3, this class would no longer be a singleton if the words `implements Serializable` were added to its declaration. It doesn’t matter whether the class uses the default serialized form or a custom serialized form (Item 87), nor does it matter whether the class provides an explicit readObject method (Item 88). Any `readObject` method, whether explicit or default, returns a newly created instance, which will not be the same instance that was created at class initialization time.”
* “The `readResolve` feature allows you to substitute another instance for the one created by `readObject` [Serialization, 3.7]. ”
  * “If the class of an object being deserialized defines a `readResolve` method with the proper declaration, this method is invoked on the newly created object after it is deserialized. The object reference returned by this method is then returned in place of the newly created object.”
* “If the Elvis class is made to implement `Serializable`, the following `readResolve` method suffices to guarantee the singleton property:”


```java
// readResolve for instance control - you can do better!
private Object readResolve() {
    // Return the one true Elvis and let the garbage collector
    // take care of the Elvis impersonator.
    return INSTANCE;
}
```

* “This method ignores the deserialized object, returning the distinguished `Elvis` instance that was created when the class was initialized. Therefore, the serialized form of an `Elvis` instance need not contain any real data; all instance fields should be declared transient.”
* “In fact, **if you depend on `readResolve` for instance control, all instance fields with object reference types must be declared `transient`**.”


```java
// Broken singleton - has nontransient object reference field!
public class Elvis implements Serializable {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() { }

    private String[] favoriteSongs =
        { "Hound Dog", "Heartbreak Hotel" };
    public void printFavorites() {
        System.out.println(Arrays.toString(favoriteSongs));
    }

    private Object readResolve() {
        return INSTANCE;
    }
} 
```

```java
public class ElvisStealer implements Serializable {
    static Elvis impersonator;
    private Elvis payload;

    private Object readResolve() {
        // Save a reference to the "unresolved" Elvis instance
        impersonator = payload;

        // Return object of correct type for favoriteSongs field
        return new String[] { "A Fool Such as I" };
    }
    private static final long serialVersionUID = 0;
}
```

* “If you write your serializable instance-controlled class as an enum, Java guarantees you that there can be no instances besides the declared constants, unless an attacker abuses a privileged method such as `AccessibleObject.setAccessible`. Any attacker who can do that already has sufficient privileges to execute arbitrary native code, and all bets are off.”


```java
// Enum singleton - the preferred approach
public enum Elvis {
    INSTANCE;
    private String[] favoriteSongs =
        { "Hound Dog", "Heartbreak Hotel" };
    public void printFavorites() {
        System.out.println(Arrays.toString(favoriteSongs));
    }
}
```

* “The use of `readResolve` for instance control is not obsolete. If you have to write a serializable instance-controlled class whose instances are not known at compile time, you will not be able to represent the class as an enum type.”
* **“The accessibility of `readResolve` is significant.”**
  * “If you place a `readResolve` method on a final class, it should be private.”
  * “If you place a `readResolve` method on a nonfinal class, you must carefully consider its accessibility.”
    * “If it is private, it will not apply to any subclasses.”
    * “If it is package-private, it will apply only to subclasses in the same package.”
    * “If it is protected or public, it will apply to all subclasses that do not override it.”
    * “If a `readResolve` method is protected or public and a subclass does not override it, deserializing a subclass instance will produce a superclass instance, which is likely to cause a `ClassCastException`.”
* **“To summarize, use enum types to enforce instance control invariants wherever possible. If this is not possible and you need a class to be both serializable and instance-controlled, you must provide a `readResolve` method and ensure that all of the class’s instance fields are either primitive or transient.”**

## Item 90: Consider serialization proxies instead of serialized instances

* “First, design a private static nested class that concisely represents the logical state of an instance of the enclosing class. This nested class is known as the *serialization proxy* of the enclosing class.”
  * “It should have a single constructor, whose parameter type is the enclosing class.”
  * “This constructor merely copies the data from its argument: it need not do any consistency checking or defensive copying.”
  * “Both the enclosing class and its serialization proxy must be declared to implement `Serializable`.”


```java
// Serialization proxy for Period class
private static class SerializationProxy implements Serializable {
    private final Date start;
    private final Date end;

    SerializationProxy(Period p) {
        this.start = p.start;
        this.end = p.end;
    }

    private static final long serialVersionUID =
        234098243823485285L; // Any number will do (Item  87)
}
```

* “Next, add the following `writeReplace` method to the enclosing class.”
  * “The presence of this method on the enclosing class causes the serialization system to emit a `SerializationProxy` instance instead of an instance of the enclosing class.”
* “With this `writeReplace` method in place, the serialization system will never generate a serialized instance of the enclosing class, but an attacker might fabricate one in an attempt to violate the class’s invariants. To guarantee that such an attack would fail, merely add this `readObject` method to the enclosing class:”


```java
// writeReplace method for the serialization proxy pattern
private Object writeReplace() {
    return new SerializationProxy(this);
}
```

* “Finally, provide a `readResolve` method on the `SerializationProxy` class that returns a logically equivalent instance of the enclosing class. The presence of this method causes the serialization system to translate the serialization proxy back into an instance of the enclosing class upon deserialization.”

```java
// readResolve method for Period.SerializationProxy
private Object readResolve() {
    return new Period(start, end);    // Uses public constructor
}
```

* “Unlike the two previous approaches, this one allows the fields of `Period` to be final, which is required in order for the `Period` class to be truly immutable (Item 17). And unlike the two previous approaches, this one doesn’t involve a great deal of thought.”
* “There is another way in which the serialization proxy pattern is more powerful than defensive copying in `readObject`. The serialization proxy pattern allows the deserialized instance to have a different class from the originally serialized instance.”


```java
// EnumSet's serialization proxy
private static class SerializationProxy <E extends Enum<E>>
        implements Serializable {
    // The element type of this enum set.
    private final Class<E> elementType;

    // The elements contained in this enum set.
    private final Enum<?>[] elements;

    SerializationProxy(EnumSet<E> set) {
        elementType = set.elementType;
        elements = set.toArray(new Enum<?>[0]);
    }

    private Object readResolve() {
        EnumSet<E> result = EnumSet.noneOf(elementType);
        for (Enum<?> e : elements)
            result.add((E)e);
        return result;
    }

    private static final long serialVersionUID =
        362491234563181265L;
}
```

* **“In summary, consider the serialization proxy pattern whenever you find yourself having to write a `readObject` or `writeObject` method on a class that is not extendable by its clients. This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants.”**