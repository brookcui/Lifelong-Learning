# Chapter 12. Serialization

* “THIS chapter concerns *object serialization*, which is Java’s framework for encoding objects as byte streams (*serializing*) and reconstructing objects from their encodings (*deserializing*). Once an object has been serialized, its encoding can be sent from one VM to another or stored on disk for later deserialization. This chapter focuses on the dangers of serialization and how to minimize them.”


## Item 85: Prefer alternatives to Java serialization

* “A fundamental problem with serialization is that its *attack surface* is too big to protect, and constantly growing: Object graphs are deserialized by invoking the `readObject` method on an `ObjectInputStream`. This method is essentially a magic constructor that can be made to instantiate objects of almost any type on the class path, so long as the type implements the `Serializable` interface. In the process of deserializing a byte stream, this method can execute code from any of these types, so the code for all of these types is part of the attack surface.”
* “Without using any gadgets, you can easily mount a denial-of-service attack by causing the deserialization of a short stream that requires a long time to deserialize. Such streams are known as *deserialization bombs* [Svoboda16].”
* **“The best way to avoid serialization exploits is never to deserialize anything.”**
* **“There is no reason to use Java serialization in any new system you write.”**
  * “If you can’t avoid Java serialization entirely, perhaps because you’re working in the context of a legacy system that requires it, your next best alternative is to **never deserialize untrusted data**.”

* “The leading cross-platform structured data representations are JSON [JSON] and Protocol Buffers, also known as protobuf [Protobuf].”
  * “The most significant differences between JSON and protobuf are that JSON is text-based and human-readable, whereas protobuf is binary and substantially more efficient; and that JSON is exclusively a data representation, whereas protobuf offers *schemas* (types) to document and enforce appropriate usage. ”
* “If you can’t avoid serialization and you aren’t absolutely certain of the safety of the data you’re deserializing, use the object deserialization filtering added in Java 9 and backported to earlier releases (`java.io.ObjectInputFilter`). ”
  * “This facility lets you specify a filter that is applied to data streams before they’re deserialized. It operates at the class granularity, letting you accept or reject certain classes.”
  * “Accepting classes by default and rejecting a list of potentially dangerous ones is known as *blacklisting*; rejecting classes by default and accepting a list of those that are presumed safe is known as *whitelisting*.”
  * “**Prefer whitelisting to blacklisting**, as blacklisting only protects you against known threats.”
* **“In summary, serialization is dangerous and should be avoided. If you are designing a system from scratch, use a cross-platform structured-data representation such as JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use object deserialization filtering, but be aware that it is not guaranteed to thwart all attacks. Avoid writing serializable classes. If you must do so, exercise great caution.”**

## Item 86: Implement `Serializable` with great caution

* **“A major cost of implementing `Serializable` is that it decreases the flexibility to change a class’s implementation once it has been released.”**
  * “When a class implements `Serializable`, its byte-stream encoding (or *serialized form*) becomes part of its exported API.”
  * “If you do not make the effort to design a *custom serialized form* but merely accept the default, the serialized form will forever be tied to the class’s original internal representation.”
  * “It is possible to change the internal representation while maintaining the original serialized form (using `ObjectOutputStream.putFields` and `ObjectInputStream.readFields`), but it can be difficult and leaves visible warts in the source code.”
* “A simple example of the constraints on evolution imposed by serializability concerns *stream unique identifiers*, more commonly known as *serial version UIDs*. Every serializable class has a unique identification number associated with it.”
  * “If you do not specify this number by declaring a static final `long` field named `serialVersionUID`, the system automatically generates it at runtime by applying a cryptographic hash function (SHA-1) to the structure of the class.”
  * “This value is affected by the names of the class, the interfaces it implements, and most of its members, including synthetic members generated by the compiler. If you change any of these things, for example, by adding a convenience method, the generated serial version UID changes.”
  * “If you fail to declare a serial version UID, compatibility will be broken, resulting in an `InvalidClassException` at runtime.”
* **“A second cost of implementing `Serializable` is that it increases the likelihood of bugs and security holes (Item 85).”**
  * “Normally, objects are created with constructors; serialization is an *extralinguistic mechanism* for creating objects.”
    * “Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (Item 88).”
* **“A third cost of implementing `Serializable` is that it increases the testing burden associated with releasing a new version of a class.”**
  * “When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa. ”
  * “The need for testing is reduced if a custom serialized form is carefully designed when the class is first written (Items 87, 90).”
* **“Implementing `Serializable` is not a decision to be undertaken lightly.”**
  * “It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence.”
  * “Also, it greatly eases the use of a class as a component in another class that must implement `Serializable`.”
    * “Classes representing active entities, such as thread pools, should rarely implement `Serializable`.”
* **“Classes designed for inheritance (Item 19) should rarely implement `Serializable`, and interfaces should rarely extend it.”**
  * “Classes designed for inheritance that do implement `Serializable` include `Throwable` and `Component`. `Throwable` implements `Serializable` so RMI can send exceptions from server to client. `Component` implements `Serializable` so GUIs can be sent, saved, and restored, but even in the heyday of Swing and AWT, this facility was little-used in practice.”
  * “If you implement a class with instance fields that is both serializable and extendable, there are several risks to be aware of.”
    * “If there are any invariants on the instance field values, it is critical to prevent subclasses from overriding the `finalize` method, which the class can do by overriding `finalize` and declaring it final. Otherwise, the class will be susceptible to *finalizer attacks* (Item 8).”
    * “Finally, if the class has invariants that would be violated if its instance fields were initialized to their default values (zero for integral types, `false` for `boolean`, and `null` for object reference types), you must add this `readObjectNoData` method:”

```java
// readObjectNoData for stateful extendable serializable classes
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("Stream data required");
}
```

* “There is one caveat regarding the decision *not* to implement `Serializable`. If a class designed for inheritance is not serializable, it may require extra effort to write a serializable subclass. ”
  * “Normal deserialization of such a class requires the superclass to have an accessible parameterless constructor [Serialization, 1.10]. If you don’t provide such a constructor, subclasses are forced to use the serialization proxy pattern (Item 90).”
* **“Inner classes (Item 24) should not implement `Serializable`.”**
  * “They use compiler-generated *synthetic fields* to store references to *enclosing instances* and to store values of local variables from enclosing scopes. How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes.”
  * “A *static member class* can, however, implement `Serializable`.”
* **“To summarize, the ease of implementing `Serializable` is specious. Unless a class is to be used only in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data, implementing `Serializable` is a serious commitment that should be made with great care. Extra caution is warranted if a class permits inheritance.”**
