# Chapter 12. Serialization

* “THIS chapter concerns *object serialization*, which is Java’s framework for encoding objects as byte streams (*serializing*) and reconstructing objects from their encodings (*deserializing*). Once an object has been serialized, its encoding can be sent from one VM to another or stored on disk for later deserialization. This chapter focuses on the dangers of serialization and how to minimize them.”


## Item 85: Prefer alternatives to Java serialization

* “A fundamental problem with serialization is that its *attack surface* is too big to protect, and constantly growing: Object graphs are deserialized by invoking the `readObject` method on an `ObjectInputStream`. This method is essentially a magic constructor that can be made to instantiate objects of almost any type on the class path, so long as the type implements the `Serializable` interface. In the process of deserializing a byte stream, this method can execute code from any of these types, so the code for all of these types is part of the attack surface.”
* “Without using any gadgets, you can easily mount a denial-of-service attack by causing the deserialization of a short stream that requires a long time to deserialize. Such streams are known as *deserialization bombs* [Svoboda16].”
* **“The best way to avoid serialization exploits is never to deserialize anything.”**
* **“There is no reason to use Java serialization in any new system you write.”**
  * “If you can’t avoid Java serialization entirely, perhaps because you’re working in the context of a legacy system that requires it, your next best alternative is to **never deserialize untrusted data**.”

* “The leading cross-platform structured data representations are JSON [JSON] and Protocol Buffers, also known as protobuf [Protobuf].”
  * “The most significant differences between JSON and protobuf are that JSON is text-based and human-readable, whereas protobuf is binary and substantially more efficient; and that JSON is exclusively a data representation, whereas protobuf offers *schemas* (types) to document and enforce appropriate usage. ”
* “If you can’t avoid serialization and you aren’t absolutely certain of the safety of the data you’re deserializing, use the object deserialization filtering added in Java 9 and backported to earlier releases (`java.io.ObjectInputFilter`). ”
  * “This facility lets you specify a filter that is applied to data streams before they’re deserialized. It operates at the class granularity, letting you accept or reject certain classes.”
  * “Accepting classes by default and rejecting a list of potentially dangerous ones is known as *blacklisting*; rejecting classes by default and accepting a list of those that are presumed safe is known as *whitelisting*.”
  * “**Prefer whitelisting to blacklisting**, as blacklisting only protects you against known threats.”
* **“In summary, serialization is dangerous and should be avoided. If you are designing a system from scratch, use a cross-platform structured-data representation such as JSON or protobuf instead. Do not deserialize untrusted data. If you must do so, use object deserialization filtering, but be aware that it is not guaranteed to thwart all attacks. Avoid writing serializable classes. If you must do so, exercise great caution.”**

## Item 86: Implement `Serializable` with great caution

* **“A major cost of implementing `Serializable` is that it decreases the flexibility to change a class’s implementation once it has been released.”**
  * “When a class implements `Serializable`, its byte-stream encoding (or *serialized form*) becomes part of its exported API.”
  * “If you do not make the effort to design a *custom serialized form* but merely accept the default, the serialized form will forever be tied to the class’s original internal representation.”
  * “It is possible to change the internal representation while maintaining the original serialized form (using `ObjectOutputStream.putFields` and `ObjectInputStream.readFields`), but it can be difficult and leaves visible warts in the source code.”
* “A simple example of the constraints on evolution imposed by serializability concerns *stream unique identifiers*, more commonly known as *serial version UIDs*. Every serializable class has a unique identification number associated with it.”
  * “If you do not specify this number by declaring a static final `long` field named `serialVersionUID`, the system automatically generates it at runtime by applying a cryptographic hash function (SHA-1) to the structure of the class.”
  * “This value is affected by the names of the class, the interfaces it implements, and most of its members, including synthetic members generated by the compiler. If you change any of these things, for example, by adding a convenience method, the generated serial version UID changes.”
  * “If you fail to declare a serial version UID, compatibility will be broken, resulting in an `InvalidClassException` at runtime.”
* **“A second cost of implementing `Serializable` is that it increases the likelihood of bugs and security holes (Item 85).”**
  * “Normally, objects are created with constructors; serialization is an *extralinguistic mechanism* for creating objects.”
    * “Relying on the default deserialization mechanism can easily leave objects open to invariant corruption and illegal access (Item 88).”
* **“A third cost of implementing `Serializable` is that it increases the testing burden associated with releasing a new version of a class.”**
  * “When a serializable class is revised, it is important to check that it is possible to serialize an instance in the new release and deserialize it in old releases, and vice versa. ”
  * “The need for testing is reduced if a custom serialized form is carefully designed when the class is first written (Items 87, 90).”
* **“Implementing `Serializable` is not a decision to be undertaken lightly.”**
  * “It is essential if a class is to participate in a framework that relies on Java serialization for object transmission or persistence.”
  * “Also, it greatly eases the use of a class as a component in another class that must implement `Serializable`.”
    * “Classes representing active entities, such as thread pools, should rarely implement `Serializable`.”
* **“Classes designed for inheritance (Item 19) should rarely implement `Serializable`, and interfaces should rarely extend it.”**
  * “Classes designed for inheritance that do implement `Serializable` include `Throwable` and `Component`. `Throwable` implements `Serializable` so RMI can send exceptions from server to client. `Component` implements `Serializable` so GUIs can be sent, saved, and restored, but even in the heyday of Swing and AWT, this facility was little-used in practice.”
  * “If you implement a class with instance fields that is both serializable and extendable, there are several risks to be aware of.”
    * “If there are any invariants on the instance field values, it is critical to prevent subclasses from overriding the `finalize` method, which the class can do by overriding `finalize` and declaring it final. Otherwise, the class will be susceptible to *finalizer attacks* (Item 8).”
    * “Finally, if the class has invariants that would be violated if its instance fields were initialized to their default values (zero for integral types, `false` for `boolean`, and `null` for object reference types), you must add this `readObjectNoData` method:”

```java
// readObjectNoData for stateful extendable serializable classes
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("Stream data required");
}
```

* “There is one caveat regarding the decision *not* to implement `Serializable`. If a class designed for inheritance is not serializable, it may require extra effort to write a serializable subclass. ”
  * “Normal deserialization of such a class requires the superclass to have an accessible parameterless constructor [Serialization, 1.10]. If you don’t provide such a constructor, subclasses are forced to use the serialization proxy pattern (Item 90).”
* **“Inner classes (Item 24) should not implement `Serializable`.”**
  * “They use compiler-generated *synthetic fields* to store references to *enclosing instances* and to store values of local variables from enclosing scopes. How these fields correspond to the class definition is unspecified, as are the names of anonymous and local classes.”
  * “A *static member class* can, however, implement `Serializable`.”
* **“To summarize, the ease of implementing `Serializable` is specious. Unless a class is to be used only in a protected environment where versions will never have to interoperate and servers will never be exposed to untrusted data, implementing `Serializable` is a serious commitment that should be made with great care. Extra caution is warranted if a class permits inheritance.”**

## Item 87: Consider using a custom serialized form

* **“Do not accept the default serialized form without first considering whether it is appropriate.”**
* “The ideal serialized form of an object contains only the *logical* data represented by the object. It is independent of the physical representation.”
  * **“The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.”**

```java
// Good candidate for default serialized form
public class Name implements Serializable {
    /**
     * Last name. Must be non-null.
     * @serial
     */
    private final String lastName;

    /**
     * First name. Must be non-null.
     * @serial
     */
    private final String firstName;
    /**
     * Middle name, or null if there is none.
     * @serial
     */
    private final String middleName;

    ... // Remainder omitted
}
```

* **“Even if you decide that the default serialized form is appropriate, you often must provide a `readObject` method to ensure invariants and security.”**
* “Note that there are documentation comments on the `lastName`, `firstName`, and `middleName` fields, even though they are private. That is because these private fields define a public API, which is the serialized form of the class, and this public API must be documented. The presence of the `@serial` tag tells Javadoc to place this documentation on a special page that documents serialized forms.”


```java
// Awful candidate for default serialized form
public final class StringList implements Serializable {
    private int size = 0;
    private Entry head = null;

    private static class Entry implements Serializable {
        String data;
        Entry  next;
        Entry  previous;
    }

    ... // Remainder omitted
}
```

* **“Using the default serialized form when an object’s physical representation differs substantially from its logical data content has four disadvantages:”**
  * **“It permanently ties the exported API to the current internal representation.”**
  * **“It can consume excessive space.”**
  * **“It can consume excessive time.”**
  * **“It can cause stack overflows.”**
* “Here is a revised version of `StringList` with `writeObject` and `readObject` methods that implement this serialized form. As a reminder, the `transient` modifier indicates that an instance field is to be omitted from a class’s default serialized form:”


```java
// StringList with a reasonable custom serialized form
public final class StringList implements Serializable {
    private transient int size   = 0;
    private transient Entry head = null;

    // No longer Serializable!
    private static class Entry {
        String data;
        Entry  next;
        Entry  previous;
    }

    // Appends the specified string to the list
    public final void add(String s) { ... }

    /**
     * Serialize this {@code StringList} instance.
     *
     * @serialData The size of the list (the number of strings
     * it contains) is emitted ({@code int}), followed by all of
     * its elements (each a {@code String}), in the proper
     * sequence.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
        s.defaultWriteObject();
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (Entry e = head; e != null; e = e.next)
            s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numElements = s.readInt();

        // Read in all elements and insert them in list
        for (int i = 0; i < numElements; i++)
            add((String) s.readObject());
    }

    ... // Remainder omitted
}
```

* “The first thing `writeObject` does is to invoke `defaultWriteObject`, and the first thing `readObject` does is to invoke `defaultReadObject`, even though all of `StringList`’s fields are transient.”
  * “Had the earlier version’s `readObject` method failed to invoke `defaultReadObject`, the deserialization would fail with a `StreamCorruptedException`.”
* **“Before deciding to make a field nontransient, convince yourself that its value is part of the logical state of the object.”**
  * “If you use a custom serialized form, most or all of the instance fields should be labeled `transient`, as in the `StringList` example above.”
* “If you are using the default serialized form and you have labeled one or more fields `transient`, remember that these fields will be initialized to their *default values* when an instance is deserialized”
  * “If these values are unacceptable for any transient fields, you must provide a `readObject` method that invokes the `defaultReadObject` method and then restores transient fields to acceptable values (Item 88).”
  * “Alternatively, these fields can be lazily initialized the first time they are used (Item 83).”
* “Whether or not you use the default serialized form, **you must impose any synchronization on object serialization that you would impose on any other method that reads the entire state of the object**.”

```java
// writeObject for synchronized class with default serialized form
private synchronized void writeObject(ObjectOutputStream s)
        throws IOException {
    s.defaultWriteObject();
}
```

* “If you put synchronization in the `writeObject` method, you must ensure that it adheres to the same lock-ordering constraints as other activities, or you risk a resource-ordering deadlock [Goetz06, 10.1.5].”
* **“Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.”**
  * “This eliminates the serial version UID as a potential source of incompatibility (Item 86).”

  * “If no serial version UID is provided, an expensive computation is performed to generate one at runtime.”

```java
private static final long serialVersionUID = randomLongValue;
```

* “If you write a new class, it doesn’t matter what value you choose for `randomLongValue`. You can generate the value by running the `serialver` utility on the class, but it’s also fine to pick a number out of thin air.”
* “If you ever want to make a new version of a class that is incompatible with existing versions, merely change the value in the serial version UID declaration.”
  * **“Do not change the serial version UID unless you want to break compatibility with all existing serialized instances of a class.”**
* **“To summarize, if you have decided that a class should be serializable (Item 86), think hard about what the serialized form should be. Use the default serialized form *only* if it is a reasonable description of the logical state of the object; otherwise design a custom serialized form that aptly describes the object. You should allocate as much time to designing the serialized form of a class as you allocate to designing an exported method (Item 51). Just as you can’t eliminate exported methods from future versions, you can’t eliminate fields from the serialized form; they must be preserved forever to ensure serialization compatibility. Choosing the wrong serialized form can have a permanent, negative impact on the complexity and performance of a class.”**